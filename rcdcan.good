package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/brutella/can"
)

const EffFlag uint32 = 1 << 31

// -------------------- Directions / Modes --------------------

const DIR_STOP uint8 = 0
const DIR_POS  uint8 = 1
const DIR_NEG  uint8 = 255

// Flap modes
// mode: 0=stop, 1=extend_basic, 2=retract_basic, 3=step_advance, 4=go_to_step
const FLAP_STOP          uint8 = 0
const FLAP_EXTEND_BASIC  uint8 = 1
const FLAP_RETRACT_BASIC uint8 = 2
const FLAP_STEP_ADVANCE  uint8 = 3
const FLAP_GOTO_STEP     uint8 = 4

// -------------------- Axes / Instances --------------------

const AXIS_ELEVATOR uint8 = 0
const AXIS_AILERON  uint8 = 1
const AXIS_RUDDER   uint8 = 2

// Flaps instance is always 0
const INSTANCE_FLAPS uint8 = 0

// -------------------- CAN constants --------------------

var canbus *can.Bus

const (
	priorityControl = 0x02
	classActuation  = 0x09

	functionTrimCmd  = 0x10
	functionFlapCtrl = 0x12
	functionRcdTelemStat = 0x52 // NEW: RCD telemetry status

	sourceTestNode = 0x01
)

// Inhibit mask bits (NEW)
const (
	INHIBIT_FLAPS uint8 = 1 << 0
	INHIBIT_ELEV  uint8 = 1 << 1
	INHIBIT_AIL   uint8 = 1 << 2
	INHIBIT_RUD   uint8 = 1 << 3
	INHIBIT_LAND  uint8 = 1 << 4
	INHIBIT_START uint8 = 1 << 5
)

// -------------------- RCD Telemetry State (NEW) --------------------

// RcdState is a decoded/expanded view of the compact telemetry payload.
type RcdState struct {
	mutex sync.RWMutex

	// Raw bytes (last received)
	RelayBits     uint8
	InputBits     uint8
	TrimActivity  uint8 // 0=stop, 1=pos, 255=neg
	FlapMotion    uint8 // 0=stop, 1=deploy, 255=retract
	FlapStep      uint8 // 0..3
	LandingState  uint8 // 0=off, 1=steady, 2=wigwag
	InhibitMask   uint8

	// Expanded convenience fields
	Relays     [8]bool // index 0..7
	Inputs     [8]bool // index 0..7 (true == input on/low/closed)
	Inhibit    RcdInhibitFlags
}

type RcdInhibitFlags struct {
	Flaps bool
	Elev  bool
	Ail   bool
	Rud   bool
	Land  bool
	Start bool
}

// Global instance (NEW)
var rcdState RcdState

// -------------------- CAN helpers --------------------

func makeCanID(priority, cls, function, source, instance uint32) uint32 {
	const posInstance = 0
	const posSource   = 5
	const posFunction = 13
	const posClass    = 21
	const posPriority = 26

	id := uint32(0)

	id |= (priority & 0x07) << posPriority
	id |= (cls & 0x1F) << posClass
	id |= (function & 0xFF) << posFunction
	id |= (source & 0xFF) << posSource
	id |= (instance & 0x1F) << posInstance
	id |= EffFlag

	return id
}

// Extractors for class/function from your 29-bit layout (NEW)

func extractClass(id uint32) uint32 {
	const posClass = 21
	return (id >> posClass) & 0x1F
}

func extractFunction(id uint32) uint32 {
	const posFunction = 13
	return (id >> posFunction) & 0xFF
}

// Trim: payload = [direction, duration_tenths]
func sendTrimMessage(axis, direction uint8) {
	frameID := makeCanID(
		priorityControl,
		classActuation,
		functionTrimCmd,
		sourceTestNode,
		uint32(axis),
	)

	frame := can.Frame{
		ID:     frameID,
		Length: 2,
		Flags:  0,
		Res0:   0,
		Res1:   0,
	}

	frame.Data[0] = direction
	frame.Data[1] = 2 // unchanged example duration

	if err := canbus.Publish(frame); err != nil {
		log.Printf("failed to publish trim frame: %v", err)
	}
}

// Flaps: payload = [mode, param]
// mode: 0=stop, 1=extend_basic, 2=retract_basic, 3=step_advance, 4=go_to_step
// param: for go_to_step, the step index (0..3); for basic extend/retract, optional duration_tenths.
func sendFlapMessage(mode uint8, param uint8) {
	frameID := makeCanID(
		priorityControl,
		classActuation,
		functionFlapCtrl,
		sourceTestNode,
		uint32(INSTANCE_FLAPS), // instance always 0
	)

	frame := can.Frame{
		ID:     frameID,
		Length: 2,
		Flags:  0,
		Res0:   0,
		Res1:   0,
	}

	frame.Data[0] = mode
	frame.Data[1] = param

	if err := canbus.Publish(frame); err != nil {
		log.Printf("failed to publish flap frame: %v", err)
	}
}

// -------------------- Telemetry decode (NEW) --------------------

// expandBits converts a byte to a [8]bool (bit0 -> index0).
func expandBits(b byte) [8]bool {
	var out [8]bool

	for i := 0; i < 8; i++ {
		mask := byte(1) << uint(i)
		out[i] = (b & mask) != 0
	}

	return out
}

func updateRcdStateFromTelemetry(data []byte) {
	// Data layout:
	//  0: relay_bits     (1=coil ON)
	//  1: input_bits     (1=on/low/closed)
	//  2: trim_activity  (0 stop, 1 pos, 255 neg)
	//  3: flap_motion    (0 stop, 1 deploy, 255 retract)
	//  4: flap_step      (0..3)
	//  5: landing_state  (0 off, 1 steady, 2 wigwag)
	//  6: inhibit_mask   (bitfield)
	if len(data) < 7 {
		return
	}

	relayBits    := data[0]
	inputBits    := data[1]
	trimActivity := data[2]
	flapMotion   := data[3]
	flapStep     := data[4]
	landingState := data[5]
	inhibitMask  := data[6]

	relays := expandBits(relayBits)
	inputs := expandBits(inputBits)

	var inhibits RcdInhibitFlags

	inhibits.Flaps = (inhibitMask & INHIBIT_FLAPS) != 0
	inhibits.Elev  = (inhibitMask & INHIBIT_ELEV)  != 0
	inhibits.Ail   = (inhibitMask & INHIBIT_AIL)   != 0
	inhibits.Rud   = (inhibitMask & INHIBIT_RUD)   != 0
	inhibits.Land  = (inhibitMask & INHIBIT_LAND)  != 0
	inhibits.Start = (inhibitMask & INHIBIT_START) != 0

	rcdState.mutex.Lock()

	rcdState.RelayBits    = relayBits
	rcdState.InputBits    = inputBits
	rcdState.TrimActivity = trimActivity
	rcdState.FlapMotion   = flapMotion
	rcdState.FlapStep     = flapStep
	rcdState.LandingState = landingState
	rcdState.InhibitMask  = inhibitMask

	rcdState.Relays = relays
	rcdState.Inputs = inputs
	rcdState.Inhibit = inhibits

	rcdState.mutex.Unlock()
}

// rcdTelemetryHandler subscribes to all CAN frames and filters for the one we want (NEW).
func rcdTelemetryHandler(f can.Frame) {
	// Only consider Extended frames (EFF in bit 31, like we set when sending).
	if (f.ID & EffFlag) == 0 {
		return
	}

	cls := extractClass(f.ID)
	fn  := extractFunction(f.ID)

	if cls != uint32(classActuation) {
		return
	}

	if fn != uint32(functionRcdTelemStat) {
		return
	}

	// Accept payloads with >= 7 bytes; discard shorter.
	if int(f.Length) < 7 {
		return
	}

	updateRcdStateFromTelemetry(f.Data[:f.Length])
}

// -------------------- Press Managers (timed loops) --------------------

// axisTicker holds cancel for an active press loop on an axis.
type axisTicker struct {
	cancel context.CancelFunc
}

// pressManager manages per-axis 100 ms repeated sends for trim.
type pressManager struct {
	mutex  sync.Mutex
	active map[uint8]*axisTicker
	period time.Duration
}

func newPressManager(period time.Duration) *pressManager {
	return &pressManager{
		active: map[uint8]*axisTicker{},
		period: period,
	}
}

func (m *pressManager) start(axis uint8, dir uint8) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	// Stop any existing loop for this axis
	if old, ok := m.active[axis]; ok && old != nil {
		old.cancel()
		delete(m.active, axis)
	}

	ctx, cancel := context.WithCancel(context.Background())

	// Send immediately, then every period
	go func(ax uint8, direction uint8, c context.Context, p time.Duration) {
		sendTrimMessage(ax, direction)

		t := time.NewTicker(p)
		defer t.Stop()

		for {
			select {
			case <-c.Done():
				return
			case <-t.C:
				sendTrimMessage(ax, direction)
			}
		}
	}(axis, dir, ctx, m.period)

	m.active[axis] = &axisTicker{
		cancel: cancel,
	}
}

func (m *pressManager) stop(axis uint8) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if old, ok := m.active[axis]; ok && old != nil {
		old.cancel()
		delete(m.active, axis)
	}

	// Send a single STOP (direction = 0) for this axis
	sendTrimMessage(axis, DIR_STOP)
}

// flapPressManager manages a single repeating loop for flaps “basic” press/hold.
type flapPressManager struct {
	mutex  sync.Mutex
	active *axisTicker
	period time.Duration
}

func newFlapPressManager(period time.Duration) *flapPressManager {
	return &flapPressManager{
		active: nil,
		period: period,
	}
}

// startBasic starts a 100 ms loop for mode 1 or 2 with param 11
func (m *flapPressManager) startBasic(mode uint8) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	// Stop any existing loop
	if m.active != nil {
		m.active.cancel()
		m.active = nil
	}

	ctx, cancel := context.WithCancel(context.Background())

	go func(c context.Context, p time.Duration, mval uint8) {
		// Required: duration_tenths = 11 on each tick for basic modes
		const duration uint8 = 11

		// Send once immediately
		sendFlapMessage(mval, duration)

		t := time.NewTicker(p)
		defer t.Stop()

		for {
			select {
			case <-c.Done():
				return
			case <-t.C:
				sendFlapMessage(mval, duration)
			}
		}
	}(ctx, m.period, mode)

	m.active = &axisTicker{cancel: cancel}
}

// stop cancels any active repeating loop and sends STOP
func (m *flapPressManager) stop() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.active != nil {
		m.active.cancel()
		m.active = nil
	}

	sendFlapMessage(FLAP_STOP, 0)
}

// singleShot cancels any active loop and sends one message (mode/param)
func (m *flapPressManager) singleShot(mode uint8, param uint8) {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	if m.active != nil {
		m.active.cancel()
		m.active = nil
	}

	sendFlapMessage(mode, param)
}

// -------------------- HTTP UI --------------------

const uiHTML = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Trim & Flaps Control Pad</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  :root {
    --bg: #0b0f14;
    --fg: #e6edf3;
    --card: #111826;
    --muted: #9aa7b2;
  }
  html, body {
    background: var(--bg);
    color: var(--fg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .wrap {
    max-width: 780px;
    margin: 24px auto;
    padding: 16px;
  }
  h1 {
    margin: 0 0 16px 0;
    font-size: 20px;
    color: var(--muted);
    letter-spacing: 0.02em;
  }
  h2 {
    margin: 18px 0 10px 0;
    font-size: 18px;
    color: var(--muted);
  }
  .card {
    background: var(--card);
    border-radius: 14px;
    padding: 14px;
    margin-bottom: 14px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.25);
  }
  .row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr; /* Axis / NEG / POS */
    gap: 12px;
    align-items: center;
    margin-bottom: 10px;
  }
  .axis {
    font-weight: 600;
    letter-spacing: 0.03em;
  }
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
    font-size: 16px;
    padding: 12px 10px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.08);
    cursor: pointer;
    transition: transform 0.02s ease-in, background 0.2s ease, box-shadow 0.2s ease;
    color: var(--fg);
    background: #182235;
    box-shadow: 0 2px 8px rgba(0,0,0,0.20);
  }
  .btn:active {
    transform: translateY(1px);
  }
  .neg {
    background: #3a1a1a;
    border-color: rgba(182,42,42,0.5);
  }
  .neg:hover { background: #4a2323; }
  .pos {
    background: #19324e;
    border-color: rgba(43,108,176,0.5);
  }
  .pos:hover { background: #204064; }

  .flap-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr; /* Label / Retract / Extend */
    gap: 12px;
    align-items: center;
  }
  .hint {
    color: var(--muted);
    font-size: 13px;
    margin-top: 8px;
  }
  .subtle {
    color: var(--muted);
    font-size: 14px;
    margin: 8px 0 4px 0;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Trim & Flaps Control Pad</h1>

    <div class="card">
      <h2>Trim Axes</h2>

      <div class="row">
        <div class="axis">Elevator</div>
        <button class="btn neg" data-axis="0" data-dir="neg">-NEG</button>
        <button class="btn pos" data-axis="0" data-dir="pos">+POS</button>
      </div>

      <div class="row">
        <div class="axis">Aileron</div>
        <button class="btn neg" data-axis="1" data-dir="neg">-NEG</button>
        <button class="btn pos" data-axis="1" data-dir="pos">+POS</button>
      </div>

      <div class="row">
        <div class="axis">Rudder</div>
        <button class="btn neg" data-axis="2" data-dir="neg">-NEG</button>
        <button class="btn pos" data-axis="2" data-dir="pos">+POS</button>
      </div>

      <div class="hint">Press and hold (or touch and hold) to send trim commands every 100&nbsp;ms. Release to stop.</div>
    </div>

    <div class="card">
      <h2>Flaps</h2>

      <div class="subtle">Basic (press & hold)</div>
      <div class="flap-grid">
        <div class="axis">Basic</div>
        <button class="btn neg" id="flap-basic-retract">Retract</button>
        <button class="btn pos" id="flap-basic-extend">Extend</button>
      </div>

      <div class="subtle">Stepped</div>
      <div class="flap-grid">
        <div class="axis">Stepped</div>
        <button class="btn neg" id="flap-step-retract">Retract</button>
        <button class="btn pos" id="flap-step-extend">Extend</button>
      </div>

      <div class="hint">
        Basic: Retract/Extend repeat every 100&nbsp;ms while pressed (duration=11). Release sends Stop.<br/>
        Stepped: Retract sends Go-To Step 0. Extend sends Step Advance (single-shot).
      </div>
    </div>
  </div>

<script>
(function () {
  // --- Trim helpers ---
  async function postPress(axis, dir) {
    let url = '/api/press?axis=' + encodeURIComponent(axis) + '&dir=' + encodeURIComponent(dir);
    await fetch(url, { method: 'POST' });
  }

  async function postRelease(axis) {
    let url = '/api/release?axis=' + encodeURIComponent(axis);
    await fetch(url, { method: 'POST' });
  }

  // Attach to all trim buttons
  let trimButtons = Array.from(document.querySelectorAll('.btn[data-axis]'));

  trimButtons.forEach(function (btn) {
    let axis = btn.getAttribute('data-axis');
    let dir  = btn.getAttribute('data-dir');

    // Mouse
    btn.addEventListener('mousedown', function (e) {
      e.preventDefault();
      postPress(axis, dir);
    });

    btn.addEventListener('mouseup', function (e) {
      e.preventDefault();
      postRelease(axis);
    });

    btn.addEventListener('mouseleave', function (e) {
      if (e.buttons === 1) { postRelease(axis); }
    });

    // Touch
    btn.addEventListener('touchstart', function (e) {
      e.preventDefault();
      postPress(axis, dir);
    }, { passive: false });

    btn.addEventListener('touchend', function (e) {
      e.preventDefault();
      postRelease(axis);
    }, { passive: false });

    btn.addEventListener('touchcancel', function (e) {
      e.preventDefault();
      postRelease(axis);
    }, { passive: false });
  });

  // --- Flap helpers ---
  async function postFlaps(mode, param) {
    let url = '/api/flaps?mode=' + encodeURIComponent(mode);
    if (param !== undefined && param !== null) {
      url += '&param=' + encodeURIComponent(param);
    }
    await fetch(url, { method: 'POST' });
  }

  // Basic hold buttons: Retract (mode=2 while held, release=0), Extend (mode=1 while held, release=0)
  const basicRetract = document.getElementById('flap-basic-retract');
  const basicExtend  = document.getElementById('flap-basic-extend');

  // Retract basic
  basicRetract.addEventListener('mousedown', function (e) {
    e.preventDefault();
    postFlaps(2);
  });
  basicRetract.addEventListener('mouseup', function (e) {
    e.preventDefault();
    postFlaps(0);
  });
  basicRetract.addEventListener('mouseleave', function (e) {
    if (e.buttons === 1) { postFlaps(0); }
  });
  basicRetract.addEventListener('touchstart', function (e) {
    e.preventDefault();
    postFlaps(2);
  }, { passive: false });
  basicRetract.addEventListener('touchend', function (e) {
    e.preventDefault();
    postFlaps(0);
  }, { passive: false });
  basicRetract.addEventListener('touchcancel', function (e) {
    e.preventDefault();
    postFlaps(0);
  }, { passive: false });

  // Extend basic
  basicExtend.addEventListener('mousedown', function (e) {
    e.preventDefault();
    postFlaps(1);
  });
  basicExtend.addEventListener('mouseup', function (e) {
    e.preventDefault();
    postFlaps(0);
  });
  basicExtend.addEventListener('mouseleave', function (e) {
    if (e.buttons === 1) { postFlaps(0); }
  });
  basicExtend.addEventListener('touchstart', function (e) {
    e.preventDefault();
    postFlaps(1);
  }, { passive: false });
  basicExtend.addEventListener('touchend', function (e) {
    e.preventDefault();
    postFlaps(0);
  }, { passive: false });
  basicExtend.addEventListener('touchcancel', function (e) {
    e.preventDefault();
    postFlaps(0);
  }, { passive: false });

  // Stepped: Retract = mode 4 param 0. Extend = mode 3 (single-shot).
  const stepRetract = document.getElementById('flap-step-retract');
  const stepExtend  = document.getElementById('flap-step-extend');

  stepRetract.addEventListener('click', function (e) {
    e.preventDefault();
    postFlaps(4, 0);
  });

  stepExtend.addEventListener('click', function (e) {
    e.preventDefault();
    postFlaps(3);
  });

  // Safety net: release everything if page loses focus
  window.addEventListener('blur', function () {
    [0,1,2].forEach(function (ax) { postRelease(ax); });
    postFlaps(0);
  });
})();
</script>
</body>
</html>`

// -------------------- HTTP wiring --------------------

func startWebServer(pm *pressManager, fm *flapPressManager, addr string) *http.Server {
	mux := http.NewServeMux()

	// UI
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		_, _ = w.Write([]byte(uiHTML))
	})

	// Trim: start repeating send while held
	mux.HandleFunc("/api/press", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		axisStr := strings.TrimSpace(r.URL.Query().Get("axis"))
		dirStr  := strings.TrimSpace(r.URL.Query().Get("dir"))

		if axisStr == "" || dirStr == "" {
			http.Error(w, "missing axis or dir", http.StatusBadRequest)
			return
		}

		axis64, err := strconv.ParseUint(axisStr, 10, 8)
		if err != nil {
			http.Error(w, "invalid axis", http.StatusBadRequest)
			return
		}

		var dirVal uint8

		switch strings.ToLower(dirStr) {
		case "pos", "+", "plus", "positive":
			dirVal = DIR_POS
		case "neg", "-", "minus", "negative":
			dirVal = DIR_NEG
		default:
			http.Error(w, "invalid dir", http.StatusBadRequest)
			return
		}

		pm.start(uint8(axis64), dirVal)

		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write([]byte(`{"status":"ok","action":"press"}`))
	})

	// Trim: stop repeating and send STOP
	mux.HandleFunc("/api/release", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		axisStr := strings.TrimSpace(r.URL.Query().Get("axis"))
		if axisStr == "" {
			http.Error(w, "missing axis", http.StatusBadRequest)
			return
		}

		axis64, err := strconv.ParseUint(axisStr, 10, 8)
		if err != nil {
			http.Error(w, "invalid axis", http.StatusBadRequest)
			return
		}

		pm.stop(uint8(axis64))

		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write([]byte(`{"status":"ok","action":"release"}`))
	})

	// Flaps: modes per spec
	// - mode 2: start timer, send every 100ms param=11
	// - mode 1: start timer, send every 100ms param=11
	// - mode 0: stop timer, send STOP
	// - mode 4: stop timer, send once with provided param (required)
	// - mode 3: stop timer, send once
	mux.HandleFunc("/api/flaps", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		modeStr  := strings.TrimSpace(r.URL.Query().Get("mode"))
		paramStr := strings.TrimSpace(r.URL.Query().Get("param"))

		if modeStr == "" {
			http.Error(w, "missing mode", http.StatusBadRequest)
			return
		}

		mode64, err := strconv.ParseUint(modeStr, 10, 8)
		if err != nil {
			http.Error(w, "invalid mode", http.StatusBadRequest)
			return
		}
		mode := uint8(mode64)

		switch mode {
		case FLAP_RETRACT_BASIC:
			// mode 2 — start repeating param=11
			fm.startBasic(FLAP_RETRACT_BASIC)

		case FLAP_EXTEND_BASIC:
			// mode 1 — start repeating param=11
			fm.startBasic(FLAP_EXTEND_BASIC)

		case FLAP_STOP:
			// mode 0 — stop repeating and send STOP
			fm.stop()

		case FLAP_GOTO_STEP:
			// mode 4 — stop repeating, send once with param (required)
			if paramStr == "" {
				http.Error(w, "missing param for mode 4", http.StatusBadRequest)
				return
			}
			param64, err := strconv.ParseUint(paramStr, 10, 8)
			if err != nil {
				http.Error(w, "invalid param", http.StatusBadRequest)
				return
			}
			fm.singleShot(FLAP_GOTO_STEP, uint8(param64))

		case FLAP_STEP_ADVANCE:
			// mode 3 — stop repeating, send once
			fm.singleShot(FLAP_STEP_ADVANCE, 0)

		default:
			http.Error(w, fmt.Sprintf("unsupported mode %d", mode), http.StatusBadRequest)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		_, _ = w.Write([]byte(`{"status":"ok","component":"flaps"}`))
	})

	srv := &http.Server{
		Addr:    addr,
		Handler: mux,
	}

	go func() {
		log.Printf("Web UI listening on %s", addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Printf("web server error: %v", err)
		}
	}()

	return srv
}

// -------------------- main --------------------

func main() {
	ifname   := flag.String("if", "CAN0", "CAN interface to use (e.g., CAN0)")
	httpAddr := flag.String("http", ":8081", "HTTP address for the control UI (e.g., :8081)")
	periodMs := flag.Int("period", 100, "Repeat period in ms for press sending")
	flag.Parse()

	iface, err := net.InterfaceByName(*ifname)
	if err != nil {
		log.Printf("Could not find network interface %s (%v)", *ifname, err)
		return
	}

	conn, err := can.NewReadWriteCloserForInterface(iface)
	if err != nil {
		log.Printf("Unable to open CAN bus %s. Error: %v\n", *ifname, err)
		return
	}

	bus := can.NewBus(conn)

	defer bus.Disconnect()

	canbus = bus


	// NEW: Subscribe to incoming frames, then start the rest.
	bus.SubscribeFunc(rcdTelemetryHandler)

	// Start managers and web server prior to blocking in ConnectAndPublish
	pm := newPressManager(time.Duration(*periodMs) * time.Millisecond)
	fm := newFlapPressManager(100 * time.Millisecond) // flaps fixed 100 ms per spec

	srv := startWebServer(pm, fm, *httpAddr)

	// Signal handling: stop everything, shutdown HTTP, disconnect bus
	sigch := make(chan os.Signal, 1)

	signal.Notify(
		sigch,
		os.Interrupt,
		syscall.SIGINT,
		syscall.SIGTERM,
	)

	go func() {
		<-sigch

		// Trim: ensure STOP sent
		pm.stop(AXIS_ELEVATOR)
		pm.stop(AXIS_AILERON)
		pm.stop(AXIS_RUDDER)

		// Flaps: ensure STOP sent
		fm.stop()

		// Shutdown HTTP
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()

		_ = srv.Shutdown(ctx)

		// Disconnect bus to unblock ConnectAndPublish
		_ = bus.Disconnect()
	}()

	log.Printf("Connecting to CAN and publishing…")
	bus.ConnectAndPublish()

	log.Println("Exiting.")
}